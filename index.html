<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zhang Design - Kinetic Archive</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        const mouse = { x: undefined, y: undefined, radius: 120 };

        const GRAVITY = 0.15; 
        const FRICTION = 0.8; 

        // 这里的文字将被转化为物理对象
        const WORDS = [
            "ZHANGDESIGN", 
            "KASSEL GERMANY", 
            "TIANJIN CHINA", 
            "HONGZHANG@HOTMAIL.DE"
        ];

        class Particle {
            constructor(x, y, radius, isText = false, text = "") {
                this.x = x;
                this.y = y;
                this.isText = isText;
                this.text = text;
                this.radius = isText ? ctx.measureText(text).width / 1.8 : radius;
                this.velocity = { x: (Math.random() - 0.5) * 2, y: Math.random() * 2 };
                this.color = isText ? "#fff" : `rgba(255, 255, 255, ${Math.random() * 0.4 + 0.2})`;
            }

            draw() {
                if (this.isText) {
                    ctx.font = "300 14px Helvetica";
                    ctx.fillStyle = "#fff";
                    ctx.textAlign = "center";
                    ctx.fillText(this.text, this.x, this.y);
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
            }

            update() {
                // 鼠标交互 (斥力)
                if (mouse.x && mouse.y) {
                    let dx = mouse.x - this.x;
                    let dy = mouse.y - this.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < mouse.radius) {
                        this.velocity.x -= (dx / dist) * 0.5;
                        this.velocity.y -= (dy / dist) * 0.5;
                    }
                }

                this.velocity.y += GRAVITY;
                this.x += this.velocity.x;
                this.y += this.velocity.y;

                // 底部边界
                if (this.y + this.radius > canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.velocity.y *= -FRICTION;
                }
                // 左右边界
                if (this.x + this.radius > canvas.width || this.x - this.radius < 0) {
                    this.velocity.x *= -FRICTION;
                }

                // 相互碰撞逻辑
                for (let p of particles) {
                    if (this === p) continue;
                    let dx = this.x - p.x;
                    let dy = this.y - p.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    let minDist = this.radius + p.radius;

                    if (dist < minDist) {
                        let angle = Math.atan2(dy, dx);
                        let tx = this.x + Math.cos(angle) * minDist;
                        let ty = this.y + Math.sin(angle) * minDist;
                        let ax = (tx - p.x) * 0.1;
                        let ay = (ty - p.y) * 0.1;
                        this.velocity.x += ax;
                        this.velocity.y += ay;
                        p.velocity.x -= ax;
                        p.velocity.y -= ay;
                    }
                }
                this.draw();
            }
        }

        function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            particles = [];
            ctx.font = "14px Helvetica"; // 预设字体以测量宽度

            // 初始化文字粒子 (从顶部掉落)
            WORDS.forEach((text, i) => {
                let x = (canvas.width / (WORDS.length + 1)) * (i + 1);
                particles.push(new Particle(x, 20, 0, true, text));
            });

            // 初始圆点粒子
            for (let i = 0; i < 40; i++) {
                spawnDot();
            }
        }

        function spawnDot() {
            let r = Math.random() * 8 + 3;
            particles.push(new Particle(Math.random() * canvas.width, -50, r));
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => p.update());
            
            // 限制圆点数量，并持续从顶部生成
            if (particles.length < 120 && Math.random() < 0.05) spawnDot();
            
            requestAnimationFrame(animate);
        }

        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('resize', init);
        
        init();
        animate();
    </script>
</body>
</html>
